"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encode = void 0;
var tslib_1 = require("tslib");
var operations = tslib_1.__importStar(require("../../operations"));
var toBase64_1 = require("../../../util/base64/toBase64");
var clock_1 = require("../../clock");
var encodeTimestamp = function (ts) {
    return ts.sid === 1 ? ts.time : [ts.sid, ts.time];
};
var encode = function (patch) {
    var e_1, _a;
    var id = patch.getId();
    if (!id)
        throw new Error('PATCH_EMPTY');
    var ops = [];
    var res = {
        id: encodeTimestamp(id),
        ops: ops,
    };
    if (patch.meta !== undefined)
        res.meta = patch.meta;
    try {
        for (var _b = tslib_1.__values(patch.ops), _c = _b.next(); !_c.done; _c = _b.next()) {
            var op = _c.value;
            if (op instanceof operations.NewConOp) {
                var val = op.val;
                if (val instanceof clock_1.Timestamp) {
                    ops.push({ op: 'con', timestamp: true, value: encodeTimestamp(val) });
                }
                else {
                    ops.push({ op: 'con', value: val });
                }
            }
            else if (op instanceof operations.NewObjOp) {
                ops.push({ op: 'obj' });
            }
            else if (op instanceof operations.NewVecOp) {
                ops.push({ op: 'vec' });
            }
            else if (op instanceof operations.NewArrOp) {
                ops.push({ op: 'arr' });
            }
            else if (op instanceof operations.NewStrOp) {
                ops.push({ op: 'str' });
            }
            else if (op instanceof operations.NewBinOp) {
                ops.push({ op: 'bin' });
            }
            else if (op instanceof operations.NewValOp) {
                ops.push({ op: 'val', value: encodeTimestamp(op.val) });
            }
            else if (op instanceof operations.InsObjOp) {
                ops.push({
                    op: 'ins_obj',
                    obj: encodeTimestamp(op.obj),
                    value: op.data.map(function (_a) {
                        var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
                        return [key, encodeTimestamp(value)];
                    }),
                });
            }
            else if (op instanceof operations.InsVecOp) {
                ops.push({
                    op: 'ins_vec',
                    obj: encodeTimestamp(op.obj),
                    value: op.data.map(function (_a) {
                        var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
                        return [key, encodeTimestamp(value)];
                    }),
                });
            }
            else if (op instanceof operations.InsValOp) {
                ops.push({
                    op: 'ins_val',
                    obj: encodeTimestamp(op.obj),
                    value: encodeTimestamp(op.val),
                });
            }
            else if (op instanceof operations.InsStrOp) {
                ops.push({
                    op: 'ins_str',
                    obj: encodeTimestamp(op.obj),
                    after: encodeTimestamp(op.ref),
                    value: op.data,
                });
            }
            else if (op instanceof operations.InsBinOp) {
                ops.push({
                    op: 'ins_bin',
                    obj: encodeTimestamp(op.obj),
                    after: encodeTimestamp(op.ref),
                    value: (0, toBase64_1.toBase64)(op.data),
                });
            }
            else if (op instanceof operations.InsArrOp) {
                ops.push({
                    op: 'ins_arr',
                    obj: encodeTimestamp(op.obj),
                    after: encodeTimestamp(op.ref),
                    values: op.data.map(encodeTimestamp),
                });
            }
            else if (op instanceof operations.DelOp) {
                var encoded = {
                    op: 'del',
                    obj: encodeTimestamp(op.obj),
                    what: op.what.map(function (span) { return [span.sid, span.time, span.span]; }),
                };
                ops.push(encoded);
            }
            else if (op instanceof operations.NopOp) {
                var encoded = {
                    op: 'nop',
                };
                var length_1 = op.len;
                if (length_1 > 1)
                    encoded.len = length_1;
                ops.push(encoded);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return res;
};
exports.encode = encode;
