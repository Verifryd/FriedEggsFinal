"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = void 0;
var tslib_1 = require("tslib");
var fromBase64_1 = require("../../../util/base64/fromBase64");
var clock_1 = require("../../clock");
var PatchBuilder_1 = require("../../PatchBuilder");
var decodeId = function (time) {
    return typeof time === 'number' ? (0, clock_1.ts)(1, time) : (0, clock_1.ts)(time[0], time[1]);
};
var decode = function (data) {
    var e_1, _a;
    var id = data.id, ops = data.ops;
    var clock = typeof id === 'number' ? new clock_1.ServerVectorClock(1, id) : new clock_1.VectorClock(id[0], id[1]);
    var builder = new PatchBuilder_1.PatchBuilder(clock);
    try {
        for (var ops_1 = tslib_1.__values(ops), ops_1_1 = ops_1.next(); !ops_1_1.done; ops_1_1 = ops_1.next()) {
            var op = ops_1_1.value;
            switch (op.op) {
                case 'con': {
                    if (op.timestamp) {
                        builder.const(decodeId(op.value));
                    }
                    else {
                        builder.const(op.value);
                    }
                    break;
                }
                case 'val': {
                    builder.val(decodeId(op.value));
                    break;
                }
                case 'obj': {
                    builder.obj();
                    break;
                }
                case 'vec': {
                    builder.vec();
                    break;
                }
                case 'str': {
                    builder.str();
                    break;
                }
                case 'bin': {
                    builder.bin();
                    break;
                }
                case 'arr': {
                    builder.arr();
                    break;
                }
                case 'ins_val': {
                    builder.setVal(decodeId(op.obj), decodeId(op.value));
                    break;
                }
                case 'ins_obj': {
                    builder.setKeys(decodeId(op.obj), op.value.map(function (_a) {
                        var _b = tslib_1.__read(_a, 2), key = _b[0], id = _b[1];
                        return [key, decodeId(id)];
                    }));
                    break;
                }
                case 'ins_vec': {
                    builder.insVec(decodeId(op.obj), op.value.map(function (_a) {
                        var _b = tslib_1.__read(_a, 2), key = _b[0], id = _b[1];
                        return [key, decodeId(id)];
                    }));
                    break;
                }
                case 'ins_str': {
                    builder.insStr(decodeId(op.obj), decodeId(op.after || op.obj), op.value);
                    break;
                }
                case 'ins_bin': {
                    builder.insBin(decodeId(op.obj), decodeId(op.after || op.obj), (0, fromBase64_1.fromBase64)(op.value));
                    break;
                }
                case 'ins_arr': {
                    builder.insArr(decodeId(op.obj), decodeId(op.after || op.obj), op.values.map(decodeId));
                    break;
                }
                case 'del': {
                    builder.del(decodeId(op.obj), op.what.map(function (spans) { return clock_1.tss.apply(void 0, tslib_1.__spreadArray([], tslib_1.__read(spans), false)); }));
                    break;
                }
                case 'nop': {
                    builder.nop(op.len || 1);
                    break;
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (ops_1_1 && !ops_1_1.done && (_a = ops_1.return)) _a.call(ops_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var patch = builder.patch;
    patch.meta = data.meta;
    return patch;
};
exports.decode = decode;
