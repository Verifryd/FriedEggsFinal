import { CrdtDecoder } from '../../util/binary/CrdtDecoder';
import { interval, VectorClock, ServerVectorClock, ts } from '../../clock';
import { PatchBuilder } from '../../PatchBuilder';
import { CborDecoder } from '../../../json-pack/cbor/CborDecoder';
export class Decoder extends CborDecoder {
    builder;
    patchId;
    constructor(reader = new CrdtDecoder()) {
        super(reader);
    }
    decode(data) {
        const reader = this.reader;
        reader.reset(data);
        const [isServerClock, x] = reader.b1vu56();
        const clock = isServerClock ? new ServerVectorClock(1, x) : new VectorClock(x, reader.vu57());
        this.patchId = ts(clock.sid, clock.time);
        this.builder = new PatchBuilder(clock);
        const map = this.val();
        if (map instanceof Array)
            this.builder.patch.meta = map[0];
        this.decodeOperations();
        return this.builder.patch;
    }
    decodeId() {
        const reader = this.reader;
        const [isServerClock, x] = reader.b1vu56();
        if (isServerClock) {
            return ts(1, x);
        }
        else {
            const patchId = this.patchId;
            if (x === 1) {
                const delta = reader.vu57();
                return ts(patchId.sid, patchId.time + delta);
            }
            else {
                const time = reader.vu57();
                return ts(x, time);
            }
        }
    }
    decodeTss() {
        const id = this.decodeId();
        const span = this.reader.vu57();
        return interval(id, 0, span);
    }
    decodeOperations() {
        const reader = this.reader;
        while (reader.x < reader.uint8.length)
            this.decodeOperation();
    }
    decodeOperation() {
        const builder = this.builder;
        const reader = this.reader;
        const octet = reader.u8();
        const opcode = octet & 0b11111;
        switch (opcode) {
            case 0: {
                const length = octet >> 5;
                builder.const(length === 0 ? this.val() : this.decodeId());
                break;
            }
            case 1: {
                builder.val(this.decodeId());
                break;
            }
            case 2: {
                builder.obj();
                break;
            }
            case 3: {
                builder.vec();
                break;
            }
            case 4: {
                builder.str();
                break;
            }
            case 5: {
                builder.bin();
                break;
            }
            case 6: {
                builder.arr();
                break;
            }
            case 9: {
                const obj = this.decodeId();
                const val = this.decodeId();
                builder.setVal(obj, val);
                break;
            }
            case 10: {
                let length = octet >> 5;
                if (length === 0)
                    length = reader.vu57();
                const obj = this.decodeId();
                const tuples = [];
                for (let i = 0; i < length; i++) {
                    const key = this.val();
                    if (typeof key !== 'string')
                        continue;
                    const value = this.decodeId();
                    tuples.push([key, value]);
                }
                builder.setKeys(obj, tuples);
                break;
            }
            case 11: {
                let length = octet >> 5;
                if (length === 0)
                    length = reader.vu57();
                const obj = this.decodeId();
                const tuples = [];
                for (let i = 0; i < length; i++) {
                    const index = this.val();
                    if (typeof index !== 'number')
                        continue;
                    const value = this.decodeId();
                    tuples.push([index, value]);
                }
                builder.insVec(obj, tuples);
                break;
            }
            case 12: {
                let length = octet >> 5;
                if (length === 0)
                    length = reader.vu57();
                const obj = this.decodeId();
                const after = this.decodeId();
                const str = reader.utf8(length);
                builder.insStr(obj, after, str);
                break;
            }
            case 13: {
                let length = octet >> 5;
                if (length === 0)
                    length = reader.vu57();
                const obj = this.decodeId();
                const after = this.decodeId();
                const buf = reader.buf(length);
                if (!(buf instanceof Uint8Array))
                    return;
                builder.insBin(obj, after, buf);
                break;
            }
            case 14: {
                let length = octet >> 5;
                if (length === 0)
                    length = reader.vu57();
                const obj = this.decodeId();
                const after = this.decodeId();
                const elements = [];
                for (let i = 0; i < length; i++)
                    elements.push(this.decodeId());
                builder.insArr(obj, after, elements);
                break;
            }
            case 16: {
                let length = octet >> 5;
                if (length === 0)
                    length = reader.vu57();
                const obj = this.decodeId();
                const what = [];
                for (let i = 0; i < length; i++)
                    what.push(this.decodeTss());
                builder.del(obj, what);
                break;
            }
            case 17: {
                let length = octet >> 5;
                if (length === 0)
                    length = reader.vu57();
                builder.nop(length);
                break;
            }
            default: {
                throw new Error('UNKNOWN_OP');
            }
        }
    }
}
